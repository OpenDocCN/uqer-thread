# EBITDA/EV和ROIC双因子策略

##这是基于《量化投资策略：如何获取超额收益》写出来的策略。作为一个菜鸟级的策略，其思路很简单，但是收益却不错，其思路如下：
1、获取所有股票的EBITDA/EV和ROIC的数据
2、将所有股票根据EBITDA/EV进行排序，并取其中EBITDA/EV最高的20%,记为stock
3、stock里面的所有股票根据ROIC进行排序，并取其中ROIC最高的20%，记为stock
4、为了降低风险，取其中最好的40只股票，记为stock，并对stock里面所有股票进行等权买入
5、一个周期后，卖出所有的持仓，并重复上述1-4

#难点：
1、EBITDA/EV是一个比较难获取的数据，需要手动计算。
2、python功底不怎么好的同学可能不知道怎么进行排序，可能遇到排序会比较懵逼。
3、有一个要注意的点是，不能在同一次调用handle_data函数的时候同时买入卖出（个人观点，可能是因为技术不够）。这主要是因为在同一次handle_data里面，你卖出股票之后，现金并不会立刻更新。这时候买入股票，不能全部资金都调用。
     
#难点1：
	EBITDA可以在财务衍生数据里面找到。EV=净负债+流通市值，净负债也可以在财务衍生数据里面找到，流通市值则在日行情里面有。
    
#难点2：
	DataFrame里面自带的排序功能，对计算机小白非常友好。通过dataframe对象的sort()方法，我们可以快速地进行排序。sort()方法可以返回已经排序的dataframe，它有两个参数，一个是columns，可以是字符串，可以是列表，是指你要根据哪一列的值进行排序；另一个是ascending,默认是True,当该值为True，排序将根据升序进行排序；否则进行降序排序。
    假如我们有一个DataFrame叫df，有列a,b,c。如果我们想对数据根据a的数值进行排序，我们可以输入:df=df.sort(columns='a',ascending=True)

#难点3：
	为了每一次都可以全部资金调用，我们可以设变量context.buy，context.T，context.d，同时将系统的回测频率改为1天。context.d初始值为0，每次回测增加一，当回测的天数context.d%context.T==0，即到达调仓周期了，那么我们就卖出手上的持仓，并令context.buy=True。我们在handle_data里面设一个分支，当context.buy为True时，此时我们已经把之前卖出的资金拿回来了，我们就按照上面的方式进行选股，并且等权分配资金。
